# Отчет о лаботаротоной работе

Оформленн отчёт по выполнению

## Цель работы

Целью данной лабораторной работы является освоение конфигурации Spring-приложений с использованием аннотаций, включая внедрение зависимостей через @Component, параметров через @Value и SpEL, а также реализацию новых компонентов и измерение производительности с помощью средств аспектно-ориентированного программирования (AOP). Также в рамках работы требуется создать HTML-представление данных и использовать события жизненного цикла бинов для дополнительной инициализации.

## Выполнение работы

- Конфигурация через `@Component`, `@Autowired`, `@Value`, `@Primary`
- Имя CSV-файла читается из `application.properties`
- Таблица сохраняется в HTML-файл (`products.html`)
- Используется AOP для замера времени парсинга
- Выводится дата инициализации бина `ResourceFileReader`


вводим для начала как в первой работе gradle init
не забываем про chcp 65001 для вывода русского языка
Вводим gradle clean build
и на всякий сохранил для себя gradle build --refresh-dependencies
Выполнение происходит за 2 секунды.

Новая диаграмма


В проекте под названием UML diagramm.png


classDiagram

    note "Товары для зоомагазина"
    Reader <|.. ResourceFileReader
    Parser <|.. CSVParser
    ProductProvider <|.. ConcreteProductProvider
    ConcreteProductProvider o-- Parser
    ConcreteProductProvider o-- Reader
    Renderer <|.. ConsoleTableRenderer
    Renderer <|.. HTMLTableRenderer
    HTMLTableRenderer o-- ProductProvider
    ConsoleTableRenderer o-- ProductProvider
    ProductProvider .. Product
    Parser .. Product

    class Product {
        +long productId
        +String name
        +String description
        +int categoryId
        +BigDecimal price
        +int stockQuantity
        +String imageUrl
        +Date createdAt
        +Date updatedAt
    }

    class Reader {
        + String read()
    }
    <<interface>> Reader

    class ResourceFileReader {
        + String read()
    }

    class Parser {
        + List[Product] parse(String)
    }
    <<interface>> Parser

    class CSVParser {
        + List[Product] parse(String)
    }

    class Renderer {
        + void render()
    }
    <<interface>> Renderer

    class HTMLTableRenderer {
        + void render()
    }

    class ConsoleTableRenderer {
        + void render()
    }

    class ProductProvider {
        + List[Product] getProducts()
    }
    <<interface>> ProductProvider

    class ConcreteProductProvider {
        + List[Product] getProducts()
    }

## Контольные вопросы

1. Виды конфигурирования ApplicationContext
В Spring существует несколько видов конфигурирования ApplicationContext. Исторически первым способом была XML-конфигурация, где бины описывались вручную в .xml файлах. Позже появилась Java-конфигурация, когда настройки определяются с помощью аннотированных классов (@Configuration и методы с @Bean). Наиболее современный и удобный подход — аннотационная конфигурация, при которой используется автоматическое сканирование компонентов через @ComponentScan, а сами классы помечаются стереотипными аннотациями вроде @Component, @Service, @Repository и @Controller. Также Spring позволяет внедрять параметры из файлов свойств (application.properties или .yml) и использовать Groovy-конфигурации, хотя это встречается реже.

2. Стереотипные аннотации
Стереотипные аннотации в Spring — это специальные аннотации, с помощью которых фреймворк определяет, что класс является кандидатом для управления контейнером. @Component — универсальная аннотация для любого компонента. @Service применяется к классам, реализующим бизнес-логику. @Repository используется для компонентов, работающих с базой данных, и включает автоматическую обработку исключений. @Controller применяется в веб-приложениях для обозначения контроллеров, а @RestController — для REST API, он объединяет @Controller и @ResponseBody.

3. Инъекция зависимостей. Виды автоматического связывания
Инъекция зависимостей (Dependency Injection) — это механизм автоматической передачи зависимостей в бины. В Spring есть несколько способов автоматического связывания (autowiring): по имени (byName), когда имя бина совпадает с именем свойства; по типу (byType), когда тип поля совпадает с типом единственного доступного бина; через конструктор (constructor), когда зависимости передаются при создании объекта. Аннотации @Autowired и @Inject позволяют внедрять зависимости автоматически по типу, а @Resource — по имени.

4. Внедрение простых параметров в бин
Простые параметры можно внедрять в бин с помощью аннотации @Value. Значение может быть напрямую задано в коде (@Value("Hello")) или получено из файла конфигурации (@Value("${property.name}")).

5. Внедрение параметров с помощью SpEL
Более гибкий способ — использование языка выражений Spring (SpEL), который позволяет выполнять арифметику, обращаться к системным свойствам, значениям других бинов и т.д. Например, @Value("#{2 * 3}") внедрит число 6, а @Value("#{systemProperties['user.name']}") — имя текущего пользователя.

6. Режимы получения бинов
Бины в Spring могут иметь различные области (scopes). По умолчанию используется singleton — один экземпляр бина на все приложение. В режиме prototype создается новый экземпляр при каждом запросе. Также доступны области request, session, application и websocket — они используются в веб-приложениях и управляют временем жизни бинов в пределах запроса, сессии и т.д.

7. Жизненный цикл бинов
Жизненный цикл бина в Spring начинается с его создания, затем происходит внедрение зависимостей, вызов методов Aware-интерфейсов (например, BeanNameAware, ApplicationContextAware), затем выполняются методы @PostConstruct или указанные init-method. После этого бин готов к использованию. При завершении приложения вызываются методы @PreDestroy или destroy-method. При необходимости можно реализовать интерфейсы InitializingBean и DisposableBean для выполнения пользовательской логики при инициализации и завершении работы бина.

8. Что такое АОП? Основные понятия AOP
АОП (аспектно-ориентированное программирование) — это способ организации кода, при котором сквозная логика (например, логирование, безопасность, транзакции) выделяется в отдельные модули — аспекты. Основные понятия AOP включают: Aspect — модуль сквозной логики, Advice — код, исполняемый в определенный момент (до или после вызова метода), Join Point — конкретная точка в программе (например, вызов метода), Pointcut — выражение, указывающее, к каким join point применять advice, и Weaving — процесс внедрения аспектов в основной код.

9. Типы AOP в Spring
В Spring AOP реализован на основе прокси — это динамическое создание объектов-оберток, которые перехватывают вызовы методов. Есть два основных типа AOP в Spring: сам Spring AOP (на базе прокси, работает только с методами публичных Spring-бинов) и AspectJ — мощный сторонний фреймворк, который внедряет аспекты на уровне байткода и работает даже с полями и конструкторами.

10. Виды Advice
Advice может быть нескольких видов: Before — выполняется до метода, AfterReturning — после успешного выполнения, AfterThrowing — в случае исключения, After (finally) — всегда после выполнения метода, и Around — оборачивает вызов метода и может полностью контролировать его исполнение.

11. Виды Point Cut
Pointcut выражения позволяют точно указать, где применить аспект. Наиболее распространённое выражение — execution(...), которое указывает на вызовы методов. Другие виды: within(...) — ограничение по классу или пакету, args(...) — по параметрам метода, this(...) и target(...) — по типу объектов, @annotation(...) — по наличию определённых аннотаций.

12. Чем Spring AOP отличается от AspectJ
Основное отличие между Spring AOP и AspectJ заключается в механизме внедрения. Spring AOP работает только с публичными методами Spring-бинов и использует динамические прокси (в рантайме), тогда как AspectJ может внедряться в любой код (включая поля и конструкторы) на уровне компиляции или загрузки классов, обеспечивая более широкие возможности и лучшую производительность при интенсивной работе с аспектами.

## Выводы

В ходе лабораторной работы было модернизировано приложение магазина зоотоваров. Конфигурация приложения была переведена на аннотационный стиль с использованием @Component, что упростило поддержку и масштабирование проекта. С помощью @Value и SpEL реализовано гибкое получение параметров из конфигурационного файла. Добавлена HTML-реализация отображения таблицы продуктов, а также внедрено измерение времени парсинга CSV-файла с помощью AOP. Кроме того, использован механизм жизненного цикла бина для вывода информации о моменте инициализации. Все требования задания выполнены, приложение успешно запускается через gradle run и корректно работает.